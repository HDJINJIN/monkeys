{"version":3,"sources":["images/coconuts.png","images/two_ships.png","tiles.js","Offer.js","Board.js","Score.js","modal.js","Tutorial.js","index.js"],"names":["module","exports","TileRoute","tileHead","tileTail","coconuts","chests","redShips","blueShips","redAnchors","blueAnchors","this","Tile","routes","BoardRoute","boardHead","boardTail","tileRoutes","tileRoute","value","numRed","numBlue","red","blue","calcScore","tiles","tile_list","forEach","tile","index","getTiles","OfferTile","offerIndex","remainingTileIDs","handleDrop","className","draggable","onDragStart","e","ev","dataTransfer","setData","drag","Offer","Math","max","length","Board","played","board","map","onDrop","key","onDragEnter","event","preventDefault","target","style","onDragLeave","onDragOver","Score","score","scores","route","reduce","accumulator","currentValue","currentIndex","array","tallyScore","polyfill","dragImageCenterOnTouch","modalRoot","document","getElementById","Modal","props","element","createElement","appendChild","removeChild","createPortal","children","React","Component","rules","src","require","alt","PreviousButton","currentRule","setCurrentRule","onClick","disabled","NextButton","Tutorial","showRules","setShowRules","useState","shuffleArray","swapIndex","floor","random","swapValue","getBoardNodesFromFlatIndex","flatIndex","numColumns","row","topLeft","bottomLeft","updateRoutes","boardRoutes","boardNodes","convertedTileHead","convertedTileTail","headMatch","tailMatch","boardRoute","matchingRoute","newValue","matchingValue","push","newHead","newTail","concat","indexToDelete","indexOf","splice","newRoute","getInitialSetup","numRows","Object","keys","initialTiles","startingPositions","startingBoard","Array","fill","startingRoutes","head","tail","Game","startingTileIDs","drawEffect","setRemainingTileIDs","setPlayed","setRoutes","useEffect","effectiveDrawEffect","slice","getElementsByTagName","setProperty","join","getData","newPlayed","partitionedPlayed","input","output","i","partition","column","validDropQ","updatedRoutes","newRemainingTileIDs","ReactDOM","render"],"mappings":"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","file":"static/js/main.772d2cf9.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/coconuts.1ae6fa30.png\";","module.exports = __webpack_public_path__ + \"static/media/two_ships.846e2372.png\";","export class TileRoute {\n    constructor({\n        tileHead = null,\n        tileTail = null,\n        coconuts = 0,\n        chests = 0,\n        redShips = 0,\n        blueShips = 0,\n        redAnchors = 0,\n        blueAnchors = 0\n    }) {\n        // head and tail will be coordinates (0,0) to (1,1) \n        // describing their location on the tile.\n        // They will be converted to an int referring to \n        // board placement once placed.\n        // Head or tail may be null if the route terminates.\n        this.tileHead = tileHead;\n        this.tileTail = tileTail;\n\n        // The number of each type of feature on the route\n        this.coconuts = coconuts;\n        this.chests = chests;\n        this.redShips = redShips;\n        this.blueShips = blueShips;\n        this.redAnchors = redAnchors;\n        this.blueAnchors = blueAnchors;\n    }\n}\n\nexport class Tile {\n    constructor({ routes }) {\n        this.routes = routes;\n    }\n}\n\nexport class BoardRoute {\n    constructor({\n        boardHead = null,\n        boardTail = null,\n        tileRoutes = [],\n    }) {\n        // head and tail are ints corresponding to location on the board.\n        // Head and/or tail may be null if the route terminates.\n        this.boardHead = boardHead;\n        this.boardTail = boardTail;\n\n        this.tileRoutes = tileRoutes;\n    }\n\n    // Getter\n    get score() {\n        return this.calcScore();\n    }\n    // Method\n    calcScore() {\n        // Count the features across all tile routes in this route\n        let coconuts = 0;\n        let chests = 0;\n        let redShips = 0;\n        let blueShips = 0;\n        let redAnchors = 0;\n        let blueAnchors = 0;\n        for (let tileRoute of this.tileRoutes) {\n            coconuts += tileRoute.coconuts;\n            chests += tileRoute.chests;\n            redShips += tileRoute.redShips;\n            blueShips += tileRoute.blueShips;\n            redAnchors += tileRoute.redAnchors;\n            blueAnchors += tileRoute.blueAnchors;\n        }\n\n        let value = chests ? coconuts * 2 : coconuts;\n        let numRed = redAnchors ? redShips * 2 : redShips;\n        let numBlue = blueAnchors ? blueShips * 2 : blueShips;\n        if (numBlue > numRed) {\n            return { red: 0, blue: value };\n        } else if (numRed > numBlue) {\n            return { red: value, blue: 0 };\n        } else {\n            return { red: 0, blue: 0 };\n        }\n    }\n}\n\nfunction getTiles() {\n    const tile_list = [\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 2,\n                    coconuts: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 3,\n                    coconuts: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: null,\n                    blueShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 2,\n                    coconuts: 1,\n                    redShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 3,\n                    tileTail: null,\n                    blueAnchors: 1\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 1,\n                    chests: 1,\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    tileTail: 3,\n                    blueShips: 2,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: null,\n                    coconuts: 1\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    tileTail: null,\n                    blueAnchors: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 3,\n                    redShips: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: null,\n                    coconuts: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 2,\n                    redShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 3,\n                    tileTail: null,\n                    coconuts: 2,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 1,\n                    coconuts: 2,\n                }),\n                new TileRoute({\n                    tileHead: null,\n                    tileTail: 2,\n                    redShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 3,\n                    tileTail: null,\n                    blueShips: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 2,\n                    redShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: null,\n                    coconuts: 1,\n                }),\n                new TileRoute({\n                    tileHead: 3,\n                    tileTail: null,\n                    redShips: 1\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 3,\n                    blueShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 2,\n                    redShips: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 3,\n                    blueShips: 1,\n                    coconuts: 1,\n                }),\n                new TileRoute({\n                    tileHead: null,\n                    tileTail: 2,\n                    redAnchors: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: null,\n                    redShips: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: null,\n                    redShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: null,\n                    redAnchors: 1,\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    tileTail: 3,\n                    coconuts: 1,\n                    chests: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    blueAnchors: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    blueShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    tileTail: 3,\n                    redShips: 1,\n                    coconuts: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 3,\n                    redShips: 2,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    blueAnchors: 1,\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    coconuts: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 3,\n                    redShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 2,\n                    coconuts: 2,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 2,\n                    blueShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    coconuts: 1,\n                }),\n                new TileRoute({\n                    tileHead: 3,\n                    redAnchors: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 1,\n                    coconuts: 2,\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    tileTail: 3,\n                    chests: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    coconuts: 2,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 2,\n                    blueShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 3,\n                    coconuts: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    coconuts: 1,\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    blueShips: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 3,\n                    blueShips: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 3,\n                    coconuts: 2,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 2,\n                    blueShips: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    redAnchors: 1,\n                }),\n                new TileRoute({\n                    tileHead: 1,\n                    tileTail: 2,\n                    blueShips: 2,\n                }),\n                new TileRoute({\n                    tileHead: 3,\n                    coconuts: 1,\n                }),\n            ]\n        }),\n        new Tile({\n            routes: [\n                new TileRoute({\n                    tileHead: 0,\n                    tileTail: 1,\n                    chests: 1,\n                }),\n                new TileRoute({\n                    tileHead: 2,\n                    tileTail: 3,\n                    redShips: 2,\n                }),\n            ]\n        }),\n    ];\n\n    let tiles = {}\n\n    tile_list.forEach((tile, index) => tiles[index] = tile)\n\n    return tiles\n\n}\n\nexport const tiles = getTiles()","import React from 'react'\nimport { polyfill } from \"mobile-drag-drop\";\n\npolyfill({\n  dragImageCenterOnTouch: true\n});\n\nfunction OfferTile({ offerIndex, remainingTileIDs, handleDrop }) {\n  const tile = remainingTileIDs[offerIndex]\n  const className = tile ? \"square filled tile\" + tile + \" offer-tile\" : \"square offer-tile\";\n\n  function drag(ev, offerIndex, tile) {\n    ev.dataTransfer.setData(\"offerIndex\", offerIndex);\n    ev.dataTransfer.setData(\"tile\", tile);\n  }\n\n  return (\n\n    <div className={className} draggable=\"true\" onDragStart={(e) => drag(e, offerIndex, tile)} />\n\n  )\n}\n\nexport default function Offer({ remainingTileIDs, handleDrop }) {\n  return (\n    <div className=\"offer-area\">\n      <div className=\"offer\">\n        <OfferTile offerIndex=\"0\" remainingTileIDs={remainingTileIDs} handleDrop={handleDrop} />\n        <OfferTile offerIndex=\"1\" remainingTileIDs={remainingTileIDs} handleDrop={handleDrop} />\n        <OfferTile offerIndex=\"2\" remainingTileIDs={remainingTileIDs} handleDrop={handleDrop} />\n      </div>\n      <div className=\"square filled draw-pile\">\n        {Math.max(0, remainingTileIDs.length - 3)}\n      </div>\n    </div>\n  );\n}\n","import React from 'react'\nimport { polyfill } from \"mobile-drag-drop\";\n\npolyfill({\n    dragImageCenterOnTouch: true\n});\n\nexport default function Board({ played, handleDrop }) {\n\n    const board = played.map((tile, index) => {\n        const className = tile ? \"square filled tile\" + tile : \"square\";\n\n        return (\n            <div\n                onDrop={(e) => handleDrop(e, index)}\n                key={index}\n                className={className + \" droptarget\"}\n                onDragEnter={(event) => {\n                    event.preventDefault();\n                    event.target.style[\"background-color\"] = \"darkblue\"\n                }}\n                onDragLeave={(event) => {\n                    event.target.style[\"background-color\"] = \"transparent\"\n                }}\n                onDragOver={(event) => {\n                    event.preventDefault();\n                }}\n            />\n        );\n    }\n    );\n\n    return (\n        <div className=\"board\">\n            {board}\n        </div>\n    );\n}","import React from 'react'\n\nexport function tallyScore(routes) {\n  // Get the red/blue score for each route and sum them up\n  let scores = routes.map(route => route.score)\n  let redScore = scores\n    .map(score => score.red)\n    .reduce((accumulator, currentValue, currentIndex, array) => {\n      return accumulator + currentValue\n    }, 0);\n  let blueScore = scores\n    .map(score => score.blue)\n    .reduce((accumulator, currentValue, currentIndex, array) => {\n      return accumulator + currentValue\n    }, 0);\n  return { red: redScore, blue: blueScore }\n}\n\nexport default function Score({ routes }) {\n\n  const score = tallyScore(routes);\n\n  return (\n    <div className=\"score\">\n      <div className=\"red-score\">\n        <div className=\"score-icon red\" />\n        {score.red}\n      </div>\n      <div className=\"blue-score\">\n        <div className=\"score-icon blue\" />\n        {score.blue}\n      </div>\n    </div>\n  )\n}","import React from 'react';\nimport { createPortal } from 'react-dom';\n\n// Get the element with the id 'modal' from index.html\nconst modalRoot = document.getElementById( 'modal' );\n\nclass Modal extends React.Component {\n    constructor(props) {\n        super(props);\n        // Create a div to render the modal into\n        this.element = document.createElement('div');\n    }\n\n    componentDidMount() {\n        // Append the element into the DOM on mount\n        modalRoot.appendChild(this.element);\n    }\n\n    componentWillUnmount() {\n        // Remove the element from the DOM when on unmount\n        modalRoot.removeChild(this.element);\n    }\n\n    render() {\n        // Use a portal to render the children into the element\n        // (Takes any valid React child (JSX, strings, arrays, etc.) and an element in the DOM\n        return createPortal(\n            this.props.children,\n            this.element,\n        );\n    }\n}\n\nexport default Modal;\n","import React, { useState } from \"react\";\nimport Modal from \"./modal\";\n\n\nconst rules = [\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      <h1>Monkeys of the Caribbean</h1>\n      <br />\n      <br />\n      2 Players\n      <br />\n      15 Minutes\n      <br />\n      <br />\n      Game by Colin Thom\n      <br />\n      Built by Sarah Edwards\n    </div>\n    <div className=\"illustration\">\n      <div className=\"image monkey\" />\n    </div>\n  </div>,\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      A crew of monkeys&mdash;with you as the captain&mdash;overthrew their pirate overlords.\n      But it is not gold you want. Nay, coconuts are the bounty you seek.\n      Alas! There be limited space on the sea. Compete for control of sea routes to get the most coconuts.\n    </div>\n    <img src={require('./images/coconuts.png')} alt=\"coconuts\" className=\"icon\" />\n  </div>,\n\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      Two competing monkey pirate fleets vie for the most coconuts.\n      <br />\n      Each player will control a fleet.\n    </div>\n    <img src={require('./images/two_ships.png')} alt=\"ships\" className=\"icon\" />\n  </div>,\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      The board starts with the sea routes (black lines) that existed immediately after the mutinies.\n      New routes will be built from these initial routes.\n    </div>\n    <div className=\"illustration\">\n      <div className=\"image starting\" />\n    </div>\n  </div>,\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      Players take turns dragging a tile from the offer to the board.\n      At least one sea route on the new tile must connect to an existing sea route.\n    </div>\n    <div className=\"illustration\">\n      <div className=\"image turns\" />\n    </div>\n  </div>,\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      The number of coconuts on the route determines the value of the route.\n      <br />\n    </div>\n    <div className=\"illustration\">\n      <div className=\"image coconuts\" />\n      <div className=\"caption\">1 single and 2 double coconuts for 3 total coconuts</div>\n    </div>\n\n  </div>,\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      A chest doubles the number of coconuts on the route.\n      <br />\n      Multiple chests on the route have the same effect as a single chest.\n    </div>\n    <div className=\"illustration\">\n      <div className=\"image chest\" />\n      <div className=\"caption\">The chest makes these 3 coconuts count as 6 coconuts</div>\n    </div>\n  </div>,\n\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      The player with the most ships on a route owns the coconuts on that route.\n      If players tie, neither player owns the coconuts for the route.\n      As players vie for control, the score will change.\n    </div>\n    <div className=\"illustration\">\n      <div className=\"image route\" />\n      <div className=\"caption\">2 red ships and 3 blue ships means blue controls all of the coconuts on this route</div>\n    </div>\n\n  </div>,\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      An anchor at the end of a route doubles the ships of that color on the route. Two anchors of the same color on the route have the same effect as a single anchor.\n    </div>\n    <div className=\"illustration\">\n      <div className=\"image anchor\" />\n      <div className=\"caption\">The red anchor makes the 2 red ships count as 4 ships, so red owns all of the coconuts on this route.</div>\n    </div>\n  </div>,\n\n  <div className=\"tutorial-step\">\n    <div className=\"tutorial-text\">\n      The game ends once all tiles have been placed.\n      <br />\n      The player that owns the most coconuts at the end of the game wins!\n    </div>\n    <img src={require('./images/coconuts.png')} alt=\"coconuts\" className=\"icon\" />\n  </div>,\n];\n\nfunction PreviousButton({ currentRule, setCurrentRule }) {\n\n  if (currentRule !== 1) {\n\n    const handlePrevious = () => {\n      let newRule = currentRule - 1;\n      setCurrentRule(newRule);\n    };\n\n    return (\n      <button className=\"navigation-button prev-button\" onClick={handlePrevious}>&lt;</button>\n    )\n  }\n  return <button disabled className=\"navigation-button prev-button\">&lt;</button>;\n}\n\nfunction NextButton({ currentRule, setCurrentRule }) {\n  if (currentRule < rules.length) {\n\n    const handleNext = () => {\n      let newRule = currentRule + 1;\n      setCurrentRule(newRule);\n    };\n\n    return (\n      <button className=\"navigation-button next-button\" onClick={handleNext}>&gt;</button>\n    )\n  }\n  return <button disabled className=\"navigation-button next-button\">&gt;</button>;\n}\n\nexport default function Tutorial({ showRules, setShowRules }) {\n\n  const [currentRule, setCurrentRule] = useState(1);\n\n  if (showRules) {\n\n    const handleHide = () => {\n      setCurrentRule(1);\n      setShowRules(false);\n    };\n\n    return (\n      <Modal>\n        <div className=\"modal\">\n          <div className=\"tutorial\">\n            <PreviousButton\n              currentRule={currentRule}\n              setCurrentRule={setCurrentRule}\n            />\n            {rules[currentRule - 1]}\n            <button className=\"exit-button\" onClick={handleHide}>&#10005;</button>\n            <NextButton\n              currentRule={currentRule}\n              setCurrentRule={setCurrentRule}\n            />\n          </div>\n        </div>\n      </Modal>\n    );\n\n  } else {\n\n    const handleShow = () => {\n      setShowRules(true);\n    };\n\n    return (\n      <button className=\"rules-button\" onClick={handleShow}></button>\n    );\n  }\n}","import React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { tiles, BoardRoute } from './tiles.js'\nimport './rules.css';\n\nimport Offer from './Offer'\nimport Board from './Board'\nimport Score from './Score'\nimport Tutorial from './Tutorial';\n\n// TODO \n//todo uninstall react-drag-drop-container / remove from package json\n// Add game end announcement\n// fix offset dropping\n// Add undo function\n// More TESTS!\n// linter\n// \n// if screen is above certain height, move tiles and buttons/score below?\n// images are slow. Make smaller? Cache? SVG tiles???\n// force landscape mode?\n// Space the offer to match board height\n// how to not duplicate modal.js between monkeys and stars?\n// would be cool to change color of route to indicate owner\n// make rules swipe-able on mobile\n// Enable keyboard navigation for rules?\n// Enable keyboard navigation for tiles?\n// Tooltip for buttons? What is tooltip alternative for mobile?\n// check color accessibility\n// art-make the routes more level at the edges so connections are smoother\n// art- make sure things aren't too close to L/R\n\nfunction partition(input, numColumns) {\n    var output = [];\n\n    for (var i = 0; i < input.length; i += numColumns) {\n        output[output.length] = input.slice(i, i + numColumns);\n    }\n\n    return output;\n}\n\nfunction validDropQ(played, index, numColumns) {\n    // Partition the flat list of played tiles into a nested list to make the logic clearer\n    const partitionedPlayed = partition(played, numColumns)\n\n    // And convert the flat index into a row/col\n    const row = Math.floor(index / numColumns)\n    const column = index - (row * numColumns)\n\n    // If the square or the overlapping one above/below is already occupied,\n    // don't allow a tile to be dropped there\n    if (\n        partitionedPlayed[row][column] //todo this is the problem!\n        || (partitionedPlayed[row + 1] && partitionedPlayed[row + 1][column])\n        || (partitionedPlayed[row - 1] && partitionedPlayed[row - 1][column])\n    ) {\n        return false;\n    }\n\n    // If the square does not touch a tile to the left or right, don't allow the drop\n    if (\n        !(\n            partitionedPlayed[row][column + 1]\n            || partitionedPlayed[row][column - 1]\n            || (partitionedPlayed[row + 1] && partitionedPlayed[row + 1][column + 1])\n            || (partitionedPlayed[row + 1] && partitionedPlayed[row + 1][column - 1])\n            || (partitionedPlayed[row - 1] && partitionedPlayed[row - 1][column + 1])\n            || (partitionedPlayed[row - 1] && partitionedPlayed[row - 1][column - 1])\n        )\n    ) {\n        return false;\n    }\n    return true;\n}\n\nexport function shuffleArray(array) {\n    // Swap each value in an array, starting at the end of the array, with a position equal or earlier in the array.\n    for (let index = array.length - 1; index > 0; index--) {\n\n        // Get a random index from 0 to the current index of the array\n        // So for an array of length 3, the first round will be 0, 1, or 2, second round 0 or 1, and last round 0\n        // The values at this index and the current index will be swapped\n        let swapIndex = Math.floor(Math.random() * (index + 1));\n\n        // If the current index and index to swap are the same, move on to the next loop iteration\n        if (index === swapIndex) {\n            continue;\n        }\n\n        // Get the original value at index,\n        // set the value at the index to be the value at the swap index,\n        // then set the value at the swap index to be the original value at the index\n        let swapValue = array[index];\n        array[index] = array[swapIndex];\n        array[swapIndex] = swapValue;\n    }\n}\n\nexport function getBoardNodesFromFlatIndex(flatIndex, numColumns) {\n    // Convert a 0-indexed grid position to 0-indexed corner numbers of that square in a grid\n    const row = Math.floor(flatIndex / numColumns)\n    const column = flatIndex - (row * numColumns)\n\n    let topLeft = (row * (numColumns + 1) + column);\n    let topRight = topLeft + 1;\n    let bottomLeft = topLeft + numColumns + 1;\n    let bottomRight = bottomLeft + 1;\n    return [topLeft, topRight, bottomLeft, bottomRight]\n}\n\nexport function updateRoutes(boardRoutes, tile, flatIndex, numColumns) {\n\n    // Convert the row/col where the tile was placed to numbers describing \n    // the corner positions (\"nodes\") of the tile on the board\n    let boardNodes = getBoardNodesFromFlatIndex(flatIndex, numColumns);\n\n    // For each route on the placed tile:\n    for (let tileRoute of tile.routes) {\n\n        // Convert the tile head/tail (0, 1, 2, 3, or null) to the corresponding board node\n        let convertedTileHead = typeof (tileRoute.tileHead) === \"number\" ? boardNodes[tileRoute.tileHead] : null;\n        let convertedTileTail = typeof (tileRoute.tileTail) === \"number\" ? boardNodes[tileRoute.tileTail] : null;\n\n        // Find if there is an existing board route that matches the tile route head/tail\n        // There will be max 1 route match for head and tail each\n        let headMatch = null;\n        let tailMatch = null;\n\n        for (let boardRoute of boardRoutes) {\n            // If there is a head on the tile route\n            // and we haven't found a head match\n            // and the board route head or tail position matches the position of the tile route head\n            // record the board route as the head match\n            if (convertedTileHead\n                && !headMatch\n                && (boardRoute.boardHead === convertedTileHead || boardRoute.boardTail === convertedTileHead)) {\n                headMatch = boardRoute\n            }\n\n            // If there is a tail on the tile route\n            // and we haven't found a tail match\n            // and the board route head or tail position matches the position of the tile route tail\n            // record the board route as the tail match\n            if (convertedTileTail\n                && !tailMatch\n                && (boardRoute.boardHead === convertedTileTail || boardRoute.boardTail === convertedTileTail)) {\n                tailMatch = boardRoute\n            }\n\n            // If all possible matches have been found, exit.\n            // (There will be a max 1 route matching the head and 1 matching the tail.)\n            if (\n                (headMatch || !convertedTileHead)\n                && (tailMatch || !convertedTileTail)\n            ) {\n                break;\n            }\n        }\n\n        // If no match was found for the tile route head or tail,\n        // add the tile route as a new board route\n        if (!headMatch && !tailMatch) {\n            let newRoute = new BoardRoute({\n                boardHead: convertedTileHead,\n                boardTail: convertedTileTail,\n                tileRoutes: [tileRoute]\n            });\n            boardRoutes.push(newRoute);\n        }\n\n        // If only a head or tail (but not both) match was found,\n        // update the matching board route head/tail with the head/tail non-match\n        // and update the board route members\n        else if ((headMatch && !tailMatch) || (tailMatch && !headMatch)) {\n\n            // Get the matching board route\n            let matchingRoute = headMatch ? headMatch : tailMatch;\n\n            // If the board route matched at the head of the tile route,\n            // the tile tail will replace the board route head or tail\n            // Otherwise, the tile head will replace the board route head or tail\n            let newValue = headMatch ? convertedTileTail : convertedTileHead;\n\n            // Find the node where the board route joins the tile route\n            let matchingValue = headMatch ? convertedTileHead : convertedTileTail;\n\n            // Update the board route head or tail (whichever joins to the new tile) to be the new value\n            matchingRoute.boardHead === matchingValue ?\n                matchingRoute.boardHead = newValue :\n                matchingRoute.boardTail = newValue;\n\n            // Add the new tile to the route\n            matchingRoute.tileRoutes.push(tileRoute);\n        }\n\n        // If head and tail match the same board route, the route is now a loop.\n        // Set the route head/tail to null\n        // and update the board route members\n        else if (headMatch === tailMatch) {\n            headMatch.boardHead = null;\n            headMatch.boardTail = null;\n            headMatch.tileRoutes.push(tileRoute);\n        }\n\n        // Otherwise, head and tail match different routes; the routes are now joined.\n        // Update head/tail on one route,\n        // add the new tile and the tiles from the other route to the updated route,\n        // delete the other route\n        else {\n            // For both matching board routes, set the terminus that doesn't connect to the new tile to be the new head/tail\n            let newHead = ((headMatch.boardHead === convertedTileHead) || (headMatch.boardHead === convertedTileTail)) ?\n                headMatch.boardTail :\n                headMatch.boardHead;\n            let newTail = ((tailMatch.boardHead === convertedTileHead) || (tailMatch.boardHead === convertedTileTail)) ?\n                tailMatch.boardTail :\n                tailMatch.boardHead;\n\n            // Arbitrarily keep the \"head route\" as the base route\n            // Update the head and tail\n            headMatch.boardHead = newHead;\n            headMatch.boardTail = newTail;\n\n            // Update the tiles in the route\n            headMatch.tileRoutes = headMatch.tileRoutes.concat(tailMatch.tileRoutes);\n            headMatch.tileRoutes.push(tileRoute);\n\n            // Delete the other board route\n            let indexToDelete = boardRoutes.indexOf(tailMatch);\n            boardRoutes.splice(indexToDelete, 1);\n        }\n    }\n    return boardRoutes\n}\n\nexport function getInitialSetup(numRows, numColumns) {\n\n    // Shuffle the tiles\n    let remainingTileIDs = Object.keys(tiles)\n    // shuffleArray(remainingTileIDs);\n\n    // Draw 4 tiles for the starting board\n    const initialTiles = remainingTileIDs.splice(0, 4);\n\n    // Make the starting board\n    const startingPositions = [10, 24, 38, 52]; // todo can calc instead\n    const numSquares = numColumns * numRows\n    let startingBoard = Array(numSquares).fill(null);\n    initialTiles.forEach((tile, index) => {\n        let startingPosition = startingPositions[index];\n        startingBoard[startingPosition] = tile;\n    });\n\n    // Calculate the routes present on the starting tiles\n    // (Right now, each route on the tile will be a unique route; don't need to worry about the tiles connecting)\n    let startingRoutes = [];\n    initialTiles.forEach((tile, index) => {\n        // Convert the row/col where the tile was placed to board node numbers\n        let startingPosition = startingPositions[index];\n        let boardNodes = getBoardNodesFromFlatIndex(startingPosition, numColumns);\n\n        // For each route on the tile, convert the tile-relative head/tail to board-relative head/tail\n        // and add the route to the starting routes\n        for (let route of tiles[tile].routes) {\n            let head = boardNodes[route.tileHead];\n            let tail = boardNodes[route.tileTail];\n            let boardRoute = new BoardRoute({ boardHead: head, boardTail: tail, tileRoutes: [route] });\n            startingRoutes.push(boardRoute);\n        }\n    });\n\n    return ([remainingTileIDs, startingBoard, startingRoutes])\n};\n\nfunction Game() {\n\n    const numRows = 9;\n    const numColumns = 7;\n    const [startingTileIDs, startingBoard, startingRoutes] = getInitialSetup(numRows, numColumns)\n    // The box shadow around the draw stack\n    const drawEffect = [\n        \"-1px 1px rgba(27, 211, 235, 0.35)\",\n        \"-1px 1px rgba(0,0,0, 0.15)\",\n        \"-2px 2px rgba(27, 211, 235, 0.35)\",\n        \"-2px 2px rgba(0,0,0, 0.05)\",\n        \"-3px 3px rgba(27, 211, 235, 0.35)\",\n        \"-3px 3px rgba(0,0,0, 0.35)\",\n        \"-4px 4px rgba(27, 211, 235, 0.35)\",\n        \"-4px 4px rgba(0,0,0, 0.25)\",\n        \"-5px 5px rgba(27, 211, 235, 0.35)\",\n        \"-5px 5px rgba(0,0,0, 0.45)\",\n        \"-6px 6px rgba(27, 211, 235, 0.35)\",\n        \"-6px 6px rgba(0,0,0, 0.35)\",\n        \"-7px 7px rgba(27, 211, 235, 0.35)\",\n        \"-7px 7px rgba(0,0,0, 0.15)\",\n        \"-8px 8px rgba(27, 211, 235, 0.35)\",\n        \"-8px 8px rgba(0,0,0, 0.25)\",\n        \"-9px 9px rgba(27, 211, 235, 0.35)\",\n        \"-9px 9px rgba(0,0,0, 0.35)\",\n        \"-10px 10px rgba(27, 211, 235, 0.35)\",\n        \"-10px 10px rgba(0,0,0, 0.45)\",\n        \"-11px 11px rgba(27, 211, 235, 0.35)\",\n        \"-11px 11px rgba(0,0,0, 0.35)\",\n        \"-12px 12px rgba(27, 211, 235, 0.35)\",\n        \"-12px 12px rgba(0,0,0, 0.15)\",\n        \"-13px 13px rgba(27, 211, 235, 0.35)\",\n        \"-13px 13px rgba(0,0,0, 0.35)\",\n    ];\n    const [remainingTileIDs, setRemainingTileIDs] = useState(startingTileIDs);\n    const [played, setPlayed] = useState(startingBoard);\n    const [routes, setRoutes] = useState(startingRoutes);\n    const [showRules, setShowRules] = useState(false);\n    useEffect(() => {\n        const effectiveDrawEffect = drawEffect.slice(0, 2 * (remainingTileIDs.length - 3))\n        let body = document.getElementsByTagName(\"body\")[0];\n        body.style.setProperty(\"--deck-size\", effectiveDrawEffect.join(\",\"));\n    });\n\n    const handleDrop = (event, flatIndex) => {\n        event.target.style[\"background-color\"] = \"transparent\"\n\n        const offerIndex = event.dataTransfer.getData(\"offerIndex\");\n        const tile = event.dataTransfer.getData(\"tile\");\n        const newPlayed = [...played];\n\n        if (!validDropQ(newPlayed, flatIndex, numColumns)) {\n            return\n        }\n\n        // Put a token in the square where the token was dropped\n        newPlayed[flatIndex] = tile;\n\n        // Update played\n        setPlayed(newPlayed);\n\n        // update routes\n        let updatedRoutes = updateRoutes(routes.slice(), tiles[tile], flatIndex, numColumns);\n        setRoutes(updatedRoutes);\n\n        // const offerIndex = event.dragData.offerIndex;\n        let newRemainingTileIDs = [...remainingTileIDs]\n        if (newRemainingTileIDs.length > 3) {\n            // replace the played tile with the tile at the bottom of the pool\n            newRemainingTileIDs[offerIndex] = newRemainingTileIDs[newRemainingTileIDs.length - 1]\n            // remove the tile at the bottom of the pool\n            newRemainingTileIDs.splice(-1, 1)\n\n        } else {\n            // If there aren't unrevealed tiles left, replace the played tile with null\n            newRemainingTileIDs[offerIndex] = null\n        }\n\n        setRemainingTileIDs(newRemainingTileIDs)\n    };\n\n\n\n    return (\n        <div className=\"game\">\n            <Offer\n                remainingTileIDs={remainingTileIDs}\n                handleDrop={handleDrop}\n            />\n            <Board\n                played={played}\n                handleDrop={handleDrop}\n            />\n            <div className=\"off-board\">\n                <Score routes={routes} />\n                {/* <button className=\"new-game-button\" onClick={handleNewGame}></button> */}\n                <Tutorial showRules={showRules} setShowRules={setShowRules} />\n            </div>\n        </div>\n    );\n}\n\n// ========================================\n\n// ReactDOM.render(<Game />, document.getElementById(\"root\")); todo\nReactDOM.render(\n    (<Game />),\n    document.getElementById('root') || document.createElement('div') // for testing purposes\n);\n"],"sourceRoot":""}